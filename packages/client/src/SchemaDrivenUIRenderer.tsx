import React, { useState, useEffect } from 'react';
import { FormDefinition, FormField } from '@mcp-ui/generators';
import { TextInput, NumberInput, CheckboxInput } from '@mcp-ui/components';

/**
 * Props for the `SchemaDrivenUIRenderer` component.
 */
export interface SchemaDrivenUIRendererProps {
  /**
   * The definition of the form to be rendered, typically generated by
   * `@mcp-ui/generators` from an `MCPToolSchema`.
   */
  formDefinition: FormDefinition;
  /**
   * @experimental
   * Optional callback function to be invoked when the form is submitted.
   * (Currently not implemented).
   * @param data - The current form data.
   */
  // onSubmit?: (data: Record<string, any>) => void;
  /**
   * @experimental
   * Optional initial data to populate the form fields.
   * (Currently, only defaultValues from `formDefinition` are used for initialization).
   */
  // initialData?: Record<string, any>;
}

/**
 * A React component that dynamically renders a form based on a `FormDefinition`.
 * It uses components from `@mcp-ui/components` (like `TextInput`, `NumberInput`, `CheckboxInput`)
 * to render the appropriate input fields.
 *
 * The component manages the form's state (data) internally and updates it when
 * any field's value changes.
 *
 * @remarks
 * This component is central to the schema-driven UI generation flow. Future enhancements
 * will include support for more field types, layouts, validation display, and form submission.
 * The Shadow DOM exploration part (`ShadowContent`) was removed in a previous step to focus on React component rendering.
 *
 * @param props - The properties for the SchemaDrivenUIRenderer component.
 * @returns A JSX element representing the dynamically generated form.
 */
export const SchemaDrivenUIRenderer: React.FC<SchemaDrivenUIRendererProps> = ({ formDefinition /*, initialData */ }) => {
  const [formData, setFormData] = useState<Record<string, any>>({});

  // Initialize form data with default values from schema or initialData
  useEffect(() => {
    const initial: Record<string, any> = {};
    if (formDefinition && formDefinition.fields) {
      formDefinition.fields.forEach(field => {
        initial[field.name] = field.defaultValue; // Or from initialData if provided
      });
    }
    setFormData(initial);
  }, [formDefinition]);

  const handleChange = (name: string, value: any) => {
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  if (!formDefinition || !formDefinition.fields) {
    return <p>No form definition provided.</p>;
  }

  return (
    <div>
      <h3>{formDefinition.toolName}</h3>
      {formDefinition.description && <p>{formDefinition.description}</p>}
      <form onSubmit={(e) => e.preventDefault()}> {/* Basic form submit handling */}
        {formDefinition.fields.map((field: FormField) => {
          const commonProps = {
            key: field.name,
            name: field.name,
            label: field.label,
            required: field.required,
            placeholder: field.placeholder,
          };
          switch (field.type) {
            case 'text':
            case 'textarea': // TextInput can be used for textarea with a 'multiline' prop if added
              return (
                <TextInput
                  {...commonProps}
                  value={formData[field.name] || ''}
                  onChange={handleChange}
                />
              );
            case 'number':
              return (
                <NumberInput
                  {...commonProps}
                  value={formData[field.name]}
                  onChange={handleChange}
                />
              );
            case 'boolean':
              return (
                <CheckboxInput
                  {...commonProps}
                  checked={!!formData[field.name]}
                  onChange={handleChange}
                />
              );
            // case 'select': // Requires SelectInput component
            // case 'array': // Requires more complex handling
            default:
              return <p key={field.name}>Unsupported field type: {field.type}</p>;
          }
        })}
        {/* Add a submit button later */}
        {/* <button type="submit">Submit</button> */}
      </form>
      {/* For debugging data: */}
      {/* <pre>Form Data: {JSON.stringify(formData, null, 2)}</pre> */}
    </div>
  );
};
